# c_samples

> Язык `С++` добавляет к языку `С` инструментальные средства объектно-ориентированного программирования.

> Проектная философия языка `C` предусматривает использование функций в качестве строительных блоков.

[gnu](http://www.gnu.org/) - GNU's not Unix

# Manual

[make](http://www.gnu.org/software/make/) - GNU Make is a tool which controls the generation of executables

[gdb](https://www.gnu.org/software/gdb/) - The GNU Project Debugger

[gcc](https://www.gnu.org/software/gcc/) - The GNU Compiler Collection

# Samples

[fsm](https://www.codeproject.com/Articles/1275479/State-Machine-Design-in-C) - finite state machine

# Libraries:

[ut hash](http://troydhanson.github.io/uthash/) hash table for c structures.

[protobuf c](https://github.com/protobuf-c/protobuf-c) C implementation of protocol buffers.

[pthread](http://man7.org/linux/man-pages/man0/pthread.h.0p.html#top_of_page) POSIX Programmer's Manual 

---

## macro and preprocessor

Marco pattern: `#define <NAME> <VALUE>`

Numeric constant: `#define PI 3.4`

Char constant: `#define BEEP '\a'`, `#define MYCHAR 'a'`

String constant: `#define MYSTRING "string"`

## function

`Фактический аргумент` - это выражения, указанное в круглых скобках при вызове функции

`Формальный параметр` - это перменная, объявленная в заголовке определения функции

---

При следующем объявлении функции `void print_name();` компилятор `ANSI C` предположит, что вы решили воспользоваться стилем объявления, предшествующим прототипированию, и не будет проверять аргументы

Для отражения того, что функция не принимает аргументов, укажите ключевое слово `void` в круглых скобках `void print_name(void);`

---

Цикл либо рекурсия?

Обычно цикл является более удачным выбором.
Во-первых, из-за того, что каждый рекурсивный вызов создает собственный набор переменных, вариант с рекурсией использует больше памяти; каждый рекурсивный вызов помещает в стек новый набор переменных. При этом ограниценный оюъем стека может устанавливать предел количества рекурсивных вызовов.

Во-вторых, рекурси выполяется медленнее, т.к. каждый вызов функции занимает определенное время.

---

Имя функции является её адресом.

## array

Назначенные инициализаторы(C99) `int arr[6] = {[5] = 100}`, инициализирует 6й элемент массива значением 100.

Массивы переменной длины(C99) `int s = 10; int arr[s]`, здесь переменная `s` не является константным целочисленным выражением.

В языке `C` гарантируется, что при выделении пространства памяти под массив указатель на первую ячейку после конца массива `будет допустимым`. Однако несмотря на доспустимость указателя, ссылающегося на позицию после конца массива возможность его разыменования `не гарантируется`

## malloc/free

`double *d = (double*)malloc(n * sizeof(double))` - приведение к `double *` не обязательно в `c`, но требуется в `c++`, поэтому использование приведения типа упрощает перенос программы из `c` в `c++`

## storage classes - классы хранения памяти

 `auto` - автоматическая переменная характеризуется автоматической продолжительность хранения, областью видимости в пределах блока и отсутствием связывание.
```
int main(void) {
 auto int var = 1;
}
```

`register` - регистровая переменная характеризуется автоматической продолжительность хранения, областью видимости в пределах блока и отсутствием связывание. Адресс такой переменной получить нельзя. Объявление переменной как регистровой - это подсказка компилятору о неободимости обеспечить насколько возможно быстрый доступ. Если она не инициалищарованна то ее значение не определено.
```
int main(void) {
 register int quick = 1;
}
```

`static, with no linkage` - статическая переменная без связывания характеризуется статической продолжительность хранения, областью видимости в пределах блока и отсутствием связывания. Такая переменная инициализируется только один раз на этапе компиляции. Если она не инициализированна явно, ее биты устанавливаются в 0.
```
void func(void) {
 static int var = 0;
}
```

`static, with external linkage` - Объявлена как внешняя по отношение к любой функции и без использования модификатора `static`. Имеет статическую продолжительность хранения, область видимости в пределах файла и внешнее связывание. Такая переменная инициализируется только один раз на этапе компиляции. Если она не инициалирована явно ее биты устанавливаются в 0.
```
source.c
..............................
int external_linkage_var = 1;

void func(void) {
 ...

main.c
..............................
extern int external_linkage_var;

int main(void) {
 ...
```

`static, with internal linkage` - Объявлена как внешняя по отношение к любой функции c указанием модификатора класса хранения `static`. Имеет статическую продолжительность хранения, область видимости в пределах файла(единицы трансляции) и внутреннее связывание. Такая переменная инициализируется только один раз на этапе компиляции. Если она не инициалирована явно ее биты устанавливаются в 0.
```
source.c
..............................
static int internal_linkage_var = 1;

void func(void) {
 ...
```
